# Redis values for Production - Redis Cluster Mode
# 6 nodes: 3 masters + 3 replicas with automatic sharding
# Use: helm install redis ./charts/redis -f charts/redis/values-prod-cluster.yaml
#
# NOTE: This values file demonstrates Redis Cluster configuration structure.
# Full Cluster support requires:
# 1. cluster-enabled yes in redis.conf
# 2. Additional service for cluster bus port (16379)
# 3. Post-install job to initialize cluster (redis-cli --cluster create)
# 4. Cluster-aware health checks
#
# Current chart focuses on single-instance and master-replica modes.
# For production Redis Cluster, consider:
# 1. Use this as configuration reference
# 2. Bitnami Redis Cluster chart (full cluster support)
# 3. Redis Operator (advanced cluster management)

# Redis configuration
redis:
  # Redis password - REQUIRED for production cluster
  password: ""  # MUST set via --set or use existingSecret
  existingSecret: ""
  secretKeyName: redis-password

  # Redis Cluster configuration
  config: |
    # Redis 7.x configuration - Production Cluster Mode
    # Network
    bind 0.0.0.0
    protected-mode no
    port 6379
    tcp-backlog 511
    timeout 0
    tcp-keepalive 300

    # Cluster
    cluster-enabled yes
    cluster-config-file nodes.conf
    cluster-node-timeout 5000
    cluster-replica-validity-factor 10
    cluster-migration-barrier 1
    cluster-require-full-coverage yes

    # General
    daemonize no
    supervised no
    loglevel notice

    # Snapshotting (production persistence)
    save 900 1
    save 300 10
    save 60 10000
    stop-writes-on-bgsave-error yes
    rdbcompression yes
    rdbchecksum yes
    dbfilename dump.rdb
    dir /data

    # Security
    # requirepass your-password-here
    # masterauth your-password-here

    # Limits - Production cluster settings
    maxmemory 768mb
    maxmemory-policy allkeys-lru
    maxclients 10000

    # Append Only File (enabled for durability)
    appendonly yes
    appendfilename "appendonly.aof"
    appendfsync everysec
    no-appendfsync-on-rewrite no
    auto-aof-rewrite-percentage 100
    auto-aof-rewrite-min-size 64mb

    # Slow log
    slowlog-log-slower-than 10000
    slowlog-max-len 128

    # Latency monitoring
    latency-monitor-threshold 100

  existingConfigMap: ""
  args: []

# Cluster configuration (for reference - requires additional templates)
cluster:
  enabled: false  # Set to true when Cluster templates are implemented
  nodes: 6  # Total nodes (3 masters + 3 replicas)
  replicas: 1  # Replicas per master

  # Cluster bus port (node-to-node communication)
  busPort: 16379

  # Cluster initialization command (executed in post-install job)
  init:
    enabled: false
    image:
      repository: redis
      tag: "7.4.1-alpine"
    command: |
      redis-cli --cluster create \
        redis-0.redis-headless:6379 \
        redis-1.redis-headless:6379 \
        redis-2.redis-headless:6379 \
        redis-3.redis-headless:6379 \
        redis-4.redis-headless:6379 \
        redis-5.redis-headless:6379 \
        --cluster-replicas 1 \
        --cluster-yes

# Master-Slave Replication - DISABLED (Cluster mode handles replication)
replication:
  enabled: false
  replicas: 0

# Persistence - Production-grade storage (per node)
persistence:
  enabled: true
  storageClass: ""  # Use fast SSD storage class in production
  accessMode: ReadWriteOnce
  size: 10Gi  # Per node storage
  existingClaim: ""

# Replica count - 6 nodes for cluster (3 masters + 3 replicas)
# NOTE: When cluster.enabled=true, this should be cluster.nodes
replicaCount: 6

# Container image configuration
image:
  repository: redis
  pullPolicy: IfNotPresent
  tag: "7.4.1-alpine"

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

# Service account configuration
serviceAccount:
  create: true
  automount: true
  annotations: {}
  name: ""

podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "9121"

podLabels:
  environment: "production"
  tier: "cache"
  mode: "cluster"

# Pod security context
podSecurityContext:
  fsGroup: 999

# Container security context
securityContext:
  runAsUser: 999
  runAsGroup: 999
  runAsNonRoot: true
  readOnlyRootFilesystem: false
  capabilities:
    drop:
      - ALL

# Service configuration
service:
  type: ClusterIP
  port: 6379
  targetPort: 6379
  annotations:
    service.alpha.kubernetes.io/tolerate-unready-endpoints: "true"
  # Cluster mode requires additional service for cluster bus
  # cluster:
  #   port: 16379

# Resource limits - PRODUCTION cluster settings
resources:
  limits:
    cpu: 1000m     # 1 CPU per node
    memory: 1Gi    # 1GB memory per node
  requests:
    cpu: 500m      # Guaranteed 0.5 CPU
    memory: 512Mi  # Guaranteed 512Mi

# Liveness probe
livenessProbe:
  tcpSocket:
    port: redis
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1

# Readiness probe - cluster-aware health check
readinessProbe:
  exec:
    command:
      - sh
      - -c
      - |
        # Check if node is part of cluster and healthy
        redis-cli ping | grep -q PONG && \
        redis-cli cluster info | grep -q "cluster_state:ok"
  initialDelaySeconds: 15
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3
  successThreshold: 1

# Startup probe
startupProbe:
  tcpSocket:
    port: redis
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 30
  successThreshold: 1

# Autoscaling - DISABLED for StatefulSet cluster
autoscaling:
  enabled: false

# Monitoring - ENABLED for production
monitoring:
  enabled: true
  serviceMonitor:
    enabled: true
    interval: 30s
    labels:
      prometheus: kube-prometheus
    path: /metrics

# Redis Exporter - ENABLED for production metrics
metrics:
  enabled: true
  image:
    repository: oliver006/redis_exporter
    tag: v1.55.0-alpine
    pullPolicy: IfNotPresent
  resources:
    limits:
      cpu: 100m
      memory: 128Mi
    requests:
      cpu: 50m
      memory: 64Mi
  port: 9121
  # Cluster-specific exporter flags
  extraArgs:
    - "--redis.cluster-mode=true"

# Pod Disruption Budget - ENABLED for HA
podDisruptionBudget:
  enabled: true
  minAvailable: 4  # At least 4 out of 6 nodes must be available (majority)

# Network Policy - ENABLED for production security
networkPolicy:
  enabled: true
  ingress:
    # Allow from application pods (Redis port)
    - from:
      - podSelector:
          matchLabels:
            app.kubernetes.io/name: myapp
      ports:
        - protocol: TCP
          port: 6379
    # Allow cluster communication between Redis pods (both ports)
    - from:
      - podSelector:
          matchLabels:
            app.kubernetes.io/name: redis
      ports:
        - protocol: TCP
          port: 6379
        - protocol: TCP
          port: 16379
    # Allow from monitoring
    - from:
      - namespaceSelector:
          matchLabels:
            name: monitoring
      ports:
        - protocol: TCP
          port: 9121
  egress:
    # Allow DNS resolution
    - to:
      - namespaceSelector: {}
      ports:
        - protocol: UDP
          port: 53
    # Allow cluster communication between Redis pods
    - to:
      - podSelector:
          matchLabels:
            app.kubernetes.io/name: redis
      ports:
        - protocol: TCP
          port: 6379
        - protocol: TCP
          port: 16379

# Node selector - production nodes with high IOPS
nodeSelector:
  # Example: Use dedicated database nodes
  # node.kubernetes.io/instance-type: "n1-highmem-8"
  # workload: "database"
  # disktype: "ssd"
  {}

# Tolerations - for dedicated nodes
tolerations: []
  # - key: "workload"
  #   operator: "Equal"
  #   value: "database"
  #   effect: "NoSchedule"

# Affinity - STRICT for cluster (spread across zones and nodes)
affinity:
  podAntiAffinity:
    # REQUIRE each pod on different node (prevent multi-node failure)
    requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
            - key: app.kubernetes.io/name
              operator: In
              values:
                - redis
        topologyKey: kubernetes.io/hostname
    # PREFER spread across availability zones
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - redis
          topologyKey: topology.kubernetes.io/zone
      # PREFER spread masters and replicas across racks
      - weight: 50
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - redis
          topologyKey: topology.kubernetes.io/rack

# Additional environment variables
extraEnv: []

extraEnvFrom: []

# Additional volumes
extraVolumes: []

# Additional volume mounts
extraVolumeMounts: []

# Init containers - system tuning for production cluster
initContainers:
  - name: system-tuning
    image: busybox
    command:
      - sh
      - -c
      - |
        # Disable THP (Transparent Huge Pages)
        echo never > /sys/kernel/mm/transparent_hugepage/enabled || true
        echo never > /sys/kernel/mm/transparent_hugepage/defrag || true
        # Increase somaxconn for cluster communication
        sysctl -w net.core.somaxconn=65535 || true
        # Enable memory overcommit
        sysctl -w vm.overcommit_memory=1 || true
        # Increase file descriptors for cluster
        ulimit -n 65535 || true
    securityContext:
      privileged: true

# Lifecycle hooks - graceful shutdown for cluster
lifecycle:
  preStop:
    exec:
      command:
        - /bin/sh
        - -c
        - |
          # Wait for cluster to redistribute slots if needed
          sleep 5
          # Shutdown gracefully
          redis-cli shutdown save || true
