# Jellyfin Helm Chart - Default Configuration
#
# This chart follows ScriptonBasestar Helm Charts philosophy:
# - Configuration files over environment variables
# - No external database dependencies (uses SQLite)
# - Simple deployment structure
# - Hardware acceleration (GPU) support

# ========================================
# 1. Jellyfin-specific Configuration
# ========================================
jellyfin:
  # Media directories configuration
  # These are mounted from PVCs or hostPath
  mediaDirectories: []
  # Example:
  # - name: movies
  #   mountPath: /media/movies
  #   existingClaim: ""  # Optional: use existing PVC
  #   size: 100Gi
  # - name: tvshows
  #   mountPath: /media/tvshows
  #   existingClaim: ""
  #   size: 200Gi

  # GPU hardware acceleration
  # Supported: none, intel-qsv, nvidia-nvenc, amd-vaapi
  hardwareAcceleration:
    enabled: false
    type: "none"  # none, intel-qsv, nvidia-nvenc, amd-vaapi

    # Intel QuickSync Video (QSV) configuration
    intel:
      # /dev/dri/renderD128 device path
      renderDevice: "/dev/dri/renderD128"

    # NVIDIA NVENC configuration
    nvidia:
      # Requires NVIDIA GPU Operator or device plugin
      # Uses nvidia.com/gpu resource
      runtimeClassName: "nvidia"

    # AMD VAAPI configuration
    amd:
      # Uses /dev/dri for hardware acceleration
      # No additional configuration needed (uses same path as Intel QSV)

  # Transcoding configuration
  transcoding:
    # Transcoding cache directory size
    cacheSize: 10Gi
    # Number of threads for software transcoding (0 = auto)
    threads: 0

  # Network configuration
  network:
    # Published server URL (for remote access)
    publishedServerUrl: ""
    # Enable DLNA (requires host network)
    enableDlna: false

# ========================================
# 2. External Dependencies (Not Required)
# ========================================
# Jellyfin uses embedded SQLite database - no external DB needed
postgresql:
  enabled: false
mysql:
  enabled: false
redis:
  enabled: false

# ========================================
# 3. Persistence Configuration
# ========================================
persistence:
  enabled: true

  # Config volume (Jellyfin configuration and database)
  config:
    enabled: true
    storageClass: ""
    size: 5Gi
    accessMode: ReadWriteOnce
    mountPath: /config
    existingClaim: ""

  # Cache volume (transcoding cache)
  cache:
    enabled: true
    storageClass: ""
    size: 10Gi
    accessMode: ReadWriteOnce
    mountPath: /cache
    existingClaim: ""

# ========================================
# 4. Kubernetes Resources
# ========================================
replicaCount: 1

strategy:
  type: Recreate  # Jellyfin uses local SQLite database

image:
  repository: jellyfin/jellyfin
  tag: "10.10.3"
  pullPolicy: IfNotPresent

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

# ========================================
# 5. Service Account
# ========================================
serviceAccount:
  create: true
  automount: true
  annotations: {}
  name: ""

# ========================================
# 5a. RBAC Configuration
# ========================================
rbac:
  # Specifies whether RBAC resources should be created
  create: true
  # Annotations to add to the Role and RoleBinding
  annotations: {}

# ========================================
# 6. Pod Configuration
# ========================================
podAnnotations: {}
podLabels: {}

podSecurityContext:
  fsGroup: 1000
  runAsUser: 1000
  runAsGroup: 1000
  runAsNonRoot: true
  # Supplemental groups for GPU access
  # Intel QSV: 44 (video), 109 (render)
  # NVIDIA: handled by device plugin
  supplementalGroups: []

securityContext:
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: false  # Jellyfin writes to /config and /cache
  allowPrivilegeEscalation: false

# ========================================
# 7. Service Configuration
# ========================================
service:
  type: ClusterIP
  ports:
    - name: http
      port: 8096
      targetPort: 8096
      protocol: TCP
    # HTTPS port (optional)
    # - name: https
    #   port: 8920
    #   targetPort: 8920
    #   protocol: TCP
    # DLNA discovery (requires host network)
    # - name: dlna
    #   port: 1900
    #   targetPort: 1900
    #   protocol: UDP
  annotations: {}

# ========================================
# 8. Ingress Configuration
# ========================================
ingress:
  enabled: false
  className: ""
  annotations: {}
    # nginx.ingress.kubernetes.io/proxy-body-size: 10G
    # nginx.ingress.kubernetes.io/proxy-buffering: "off"
    # cert-manager.io/cluster-issuer: letsencrypt-prod
  hosts:
    - host: jellyfin.example.com
      paths:
        - path: /
          pathType: Prefix
  tls: []
  #  - secretName: jellyfin-tls
  #    hosts:
  #      - jellyfin.example.com

# ========================================
# 9. Resources
# ========================================
resources:
  limits:
    cpu: 4000m
    memory: 4Gi
  requests:
    cpu: 1000m
    memory: 2Gi

# GPU resources (added dynamically if GPU is enabled)
# Intel QSV: No explicit GPU resource request needed (uses /dev/dri)
# NVIDIA NVENC:
#   limits:
#     nvidia.com/gpu: 1

# ========================================
# 10. Health Probes
# ========================================
livenessProbe:
  enabled: true
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 60
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1

readinessProbe:
  enabled: true
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3
  successThreshold: 1

startupProbe:
  enabled: true
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 10
  periodSeconds: 5
  timeoutSeconds: 5
  failureThreshold: 30
  successThreshold: 1

# ========================================
# 11. Autoscaling (Not recommended for Jellyfin)
# ========================================
autoscaling:
  enabled: false  # Not recommended - Jellyfin uses local SQLite database
  minReplicas: 1
  maxReplicas: 3
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# ========================================
# 12. Pod Disruption Budget
# ========================================
podDisruptionBudget:
  enabled: false
  minAvailable: 1
  # maxUnavailable: 1  # Alternative to minAvailable (only one can be set)

# ========================================
# 13. Network Policy
# ========================================
networkPolicy:
  enabled: false
  ingress:
    - from:
      - podSelector: {}
      - namespaceSelector: {}
  egress:
    - to:
      - podSelector: {}

# ========================================
# 14. Monitoring (Jellyfin does not expose Prometheus metrics natively)
# ========================================
# Note: Jellyfin does not have built-in Prometheus metrics.
# To enable monitoring, you need a third-party exporter like:
# - jellyfin-exporter: https://github.com/cromefire/jellyfin-exporter
# Uncomment and configure the section below if using an exporter.
#
# monitoring:
#   enabled: false
#   serviceMonitor:
#     enabled: false
#     interval: 30s
#     scrapeTimeout: 10s
#     labels: {}
#     port: metrics
#     path: /metrics

# ========================================
# 15. Scheduling
# ========================================
# Node selector for GPU nodes
nodeSelector: {}
# Example for Intel QSV:
#   intel.feature.node.kubernetes.io/gpu: "true"
# Example for NVIDIA:
#   nvidia.com/gpu.present: "true"

tolerations: []
# Example for GPU nodes:
# - key: nvidia.com/gpu
#   operator: Exists
#   effect: NoSchedule

affinity: {}
priorityClassName: ""
topologySpreadConstraints: []

# ========================================
# 16. Extensibility
# ========================================
extraEnv: []
# Example:
# - name: JELLYFIN_PublishedServerUrl
#   value: "https://jellyfin.example.com"

extraEnvFrom: []

extraVolumes: []
# Example for Intel QSV:
# - name: dri
#   hostPath:
#     path: /dev/dri
#     type: Directory

extraVolumeMounts: []
# Example for Intel QSV:
# - name: dri
#   mountPath: /dev/dri
#   readOnly: true

initContainers: []

lifecycle: {}
