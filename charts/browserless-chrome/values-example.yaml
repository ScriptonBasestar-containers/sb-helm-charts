# Example values file for Browserless Chrome production deployment
# Copy this file to my-values.yaml and customize for your environment

# Replica configuration
replicaCount: 2

# Container image
image:
  repository: browserless/chrome
  pullPolicy: IfNotPresent
  tag: "latest"  # Or specify a specific version (e.g., "1.57.2-chrome-stable")

# Service configuration
service:
  type: ClusterIP
  port: 3000

# Ingress configuration
ingress:
  enabled: true
  className: "nginx"

  annotations:
    # SSL/TLS configuration (if using cert-manager)
    cert-manager.io/cluster-issuer: "letsencrypt-prod"

    # WebSocket support (required for browser connections)
    nginx.ingress.kubernetes.io/proxy-read-timeout: "3600"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "3600"
    nginx.ingress.kubernetes.io/websocket-services: "browserless-chrome"

    # Connection limits (optional)
    nginx.ingress.kubernetes.io/limit-connections: "50"

    # Optional: Force HTTPS redirect
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"

  hosts:
    - host: chrome.example.com
      paths:
        - path: /
          pathType: Prefix

  # TLS configuration
  tls:
    - secretName: browserless-tls
      hosts:
        - chrome.example.com

# Resource limits and requests
# Browserless Chrome requires more resources due to browser rendering
resources:
  limits:
    cpu: 2000m      # 2 CPU cores
    memory: 2Gi     # 2 GB RAM
  requests:
    cpu: 500m       # 0.5 CPU cores
    memory: 512Mi   # 512 MB RAM

# Health check configuration
livenessProbe:
  httpGet:
    path: /
    port: http
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /
    port: http
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

startupProbe:
  httpGet:
    path: /
    port: http
  initialDelaySeconds: 15
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 30

# Autoscaling (optional)
# Enable for automatic scaling based on CPU/memory usage
autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

# Pod Disruption Budget
# Ensures minimum availability during voluntary disruptions (node drains, updates)
podDisruptionBudget:
  enabled: true
  minAvailable: 1
  # Alternative: maxUnavailable: 1

# Network Policy
# Restricts network access to Browserless Chrome pods
networkPolicy:
  enabled: true
  ingress:
    # Allow traffic from ingress controller
    - from:
        - namespaceSelector:
            matchLabels:
              name: ingress-nginx
      ports:
        - protocol: TCP
          port: 3000
    # Allow traffic from application pods (adjust namespace/labels as needed)
    - from:
        - namespaceSelector:
            matchLabels:
              name: default
      ports:
        - protocol: TCP
          port: 3000
    # Allow traffic from other browserless pods (for multi-replica setups)
    - from:
        - podSelector:
            matchLabels:
              app.kubernetes.io/name: browserless-chrome
      ports:
        - protocol: TCP
          port: 3000
  egress:
    # Allow DNS resolution
    - to:
        - namespaceSelector:
            matchLabels:
              name: kube-system
      ports:
        - protocol: UDP
          port: 53
    # Allow external HTTP/HTTPS (for browser page loading)
    - to:
        - namespaceSelector: {}
      ports:
        - protocol: TCP
          port: 80
        - protocol: TCP
          port: 443

# Monitoring configuration
# ServiceMonitor for Prometheus Operator
monitoring:
  serviceMonitor:
    enabled: true
    path: /metrics
    interval: 30s
    scrapeTimeout: 10s
    additionalLabels:
      prometheus: kube-prometheus
    # Relabeling configurations (optional)
    relabelings: []
    # Target labels (optional)
    targetLabels: []

# Security context (optional)
# Note: Browserless Chrome requires specific capabilities
# podSecurityContext:
#   fsGroup: 1000

# securityContext:
#   runAsUser: 1000
#   runAsGroup: 1000
#   runAsNonRoot: true
#   capabilities:
#     add:
#       - SYS_ADMIN  # Required for Chrome sandbox

# Node selector (optional)
# Consider nodes with better CPU/memory for browser workloads
# nodeSelector:
#   disktype: ssd
#   node-role: worker
#   workload-type: cpu-intensive

# Tolerations (optional)
# tolerations:
#   - key: "node-role"
#     operator: "Equal"
#     value: "worker"
#     effect: "NoSchedule"

# Affinity rules (optional)
# Spread pods across different nodes for high availability
# affinity:
#   podAntiAffinity:
#     preferredDuringSchedulingIgnoredDuringExecution:
#       - weight: 100
#         podAffinityTerm:
#           labelSelector:
#             matchExpressions:
#               - key: app.kubernetes.io/name
#                 operator: In
#                 values:
#                   - browserless-chrome
#           topologyKey: kubernetes.io/hostname

# Additional environment variables (optional)
# Configure Browserless Chrome specific settings
# extraEnv:
#   - name: CONNECTION_TIMEOUT
#     value: "60000"
#   - name: MAX_CONCURRENT_SESSIONS
#     value: "10"
#   - name: ENABLE_DEBUGGER
#     value: "false"
#   - name: MAX_QUEUE_LENGTH
#     value: "50"
#   - name: PREBOOT_CHROME
#     value: "true"
#   - name: KEEP_ALIVE
#     value: "true"
#   - name: TOKEN
#     value: "your-secret-token-here"  # Authentication token

# Additional volumes (optional)
# volumes:
#   - name: downloads
#     emptyDir: {}

# Additional volume mounts (optional)
# volumeMounts:
#   - name: downloads
#     mountPath: /downloads
