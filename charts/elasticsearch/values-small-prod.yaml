# Elasticsearch + Kibana - Small Production Configuration
# Optimized for: Small production clusters with HA
# Mode: 3-node cluster with quorum
# Resources: Production (4-8Gi RAM, 2-4 CPU per node)
# Security: Enabled (password required)

elasticsearch:
  replicas: 3
  clusterMode: true
  clusterName: "elasticsearch-prod"

  # REQUIRED: Set password for production
  password: ""  # SET THIS VIA --set or create secret manually

  # Production heap size (50% of memory limit)
  javaOpts: "-Xms2g -Xmx2g"

  # Disable CORS for security
  httpCorsEnabled: false

  # Production monitoring
  monitoring:
    enabled: true

# Kibana enabled
kibana:
  enabled: true
  replicas: 2  # HA for Kibana

  serverHost: "0.0.0.0"
  serverName: "kibana-prod"

  # Production ingress with TLS
  ingress:
    enabled: true
    className: "nginx"
    annotations:
      cert-manager.io/cluster-issuer: "letsencrypt-prod"
      nginx.ingress.kubernetes.io/proxy-body-size: "0"
      nginx.ingress.kubernetes.io/ssl-redirect: "true"
    hosts:
      - host: kibana.example.com
        paths:
          - path: /
            pathType: Prefix
    tls:
      - secretName: kibana-tls
        hosts:
          - kibana.example.com

podManagementPolicy: Parallel

updateStrategy:
  type: RollingUpdate
  rollingUpdate:
    partition: 0

# Production resources
resources:
  limits:
    cpu: 4000m
    memory: 4Gi
  requests:
    cpu: 2000m
    memory: 2Gi

# Conservative probes for production
livenessProbe:
  httpGet:
    path: /_cluster/health?local=true
    port: http
    scheme: HTTP
  initialDelaySeconds: 120
  periodSeconds: 30
  timeoutSeconds: 10
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /_cluster/health?local=true
    port: http
    scheme: HTTP
  initialDelaySeconds: 60
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

startupProbe:
  httpGet:
    path: /_cluster/health?local=true
    port: http
    scheme: HTTP
  initialDelaySeconds: 0
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 90  # Up to 15 minutes for cluster formation

# Production storage with SSD
persistence:
  enabled: true
  storageClass: "fast-ssd"
  accessMode: ReadWriteOnce
  size: 100Gi
  annotations:
    volume.beta.kubernetes.io/storage-class: "fast-ssd"

# Production HA configuration
podDisruptionBudget:
  enabled: true
  minAvailable: 2  # Maintain quorum during updates

# Production labels
podLabels:
  environment: "production"

podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "9200"
  prometheus.io/path: "/_prometheus/metrics"

# Production security context
podSecurityContext:
  fsGroup: 1000
  runAsUser: 1000
  runAsGroup: 1000
  fsGroupChangePolicy: "OnRootMismatch"

securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  capabilities:
    drop:
      - ALL

# Node affinity for production
nodeSelector:
  node-role.kubernetes.io/worker: "true"

# Pod anti-affinity for HA
affinity:
  podAntiAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
            - key: app.kubernetes.io/component
              operator: In
              values:
                - elasticsearch
        topologyKey: kubernetes.io/hostname
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/component
                operator: In
                values:
                  - elasticsearch
          topologyKey: topology.kubernetes.io/zone

# Init container for production sysctl
initContainers:
  - name: init-sysctl
    image: busybox:latest
    command:
      - sh
      - -c
      - |
        sysctl -w vm.max_map_count=262144
        sysctl -w fs.file-max=65536
    securityContext:
      privileged: true
