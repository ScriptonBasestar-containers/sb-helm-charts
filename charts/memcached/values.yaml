# Default values for memcached
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# 1. Application-specific Configuration

memcached:
  # Maximum memory to use for object storage (in megabytes)
  maxMemory: 256

  # Maximum number of simultaneous connections
  maxConnections: 1024

  # Chunk size growth factor
  # Default 1.25 means slab sizes grow by 25% each time
  chunkSizeGrowthFactor: 1.25

  # Minimum space allocated for key+value+flags (in bytes)
  minItemSize: 48

  # Enable or disable CAS (Check and Set) operations
  # CAS provides optimistic locking for cache updates
  enableCas: true

  # Verbose logging (0=disabled, 1=enabled, 2=very verbose, 3=extremely verbose)
  verbosity: 0

  # Additional command-line arguments
  # Examples:
  #  - "-o modern"              # Enable modern memory allocator
  #  - "-o hashpower=20"        # Set hash table size (2^20 buckets)
  #  - "-o tail_repair_time=0"  # Disable tail repair for performance
  extraArgs: []

# 2. External Dependencies
# Memcached is standalone - no external dependencies required

# 3. Persistence Configuration

# Memcached is in-memory only - no persistence required
persistence:
  enabled: false

# 4. Kubernetes Resources

replicaCount: 1

image:
  repository: memcached
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  # Using Alpine for smaller image size and better security
  tag: "1.6.39-alpine3.22"

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

# Deployment strategy
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 0
    maxSurge: 1

# 5. Service Account

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# 6. Pod Configuration

podAnnotations: {}
podLabels: {}

podSecurityContext:
  fsGroup: 11211
  runAsUser: 11211
  runAsGroup: 11211
  runAsNonRoot: true

securityContext:
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 11211
  runAsGroup: 11211
  allowPrivilegeEscalation: false

# 7. Service Configuration

service:
  type: ClusterIP
  port: 11211
  annotations: {}

# 8. Ingress Configuration
# Memcached uses binary protocol - ingress not applicable
ingress:
  enabled: false

# 9. Resources

resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 128Mi

# 10. Health Probes

livenessProbe:
  enabled: true
  tcpSocket:
    port: 11211
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1

readinessProbe:
  enabled: true
  tcpSocket:
    port: 11211
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 3
  failureThreshold: 3
  successThreshold: 1

# Startup probe (for initial container startup)
startupProbe:
  enabled: true
  tcpSocket:
    port: memcached
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 10
  successThreshold: 1

# 11. Autoscaling

# HorizontalPodAutoscaler
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 5
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

# 12. Pod Disruption Budget

# Ensures minimum availability during voluntary disruptions
podDisruptionBudget:
  enabled: false
  minAvailable: 1
  # maxUnavailable: 1

# 13. Network Policy

# NetworkPolicy to restrict network access
networkPolicy:
  enabled: false
  # Ingress rules - allow from any pod by default
  ingress:
    - from:
        - podSelector: {}
      ports:
        - protocol: TCP
          port: 11211
  # Egress rules - typically memcached doesn't need egress
  egress: []

# 14. Monitoring

monitoring:
  enabled: false
  # ServiceMonitor for Prometheus Operator
  # Note: Standard memcached doesn't expose metrics
  # Consider using memcached-exporter sidecar for production monitoring
  serviceMonitor:
    enabled: false
    # Namespace for ServiceMonitor (defaults to release namespace)
    namespace: ""
    # Interval at which metrics should be scraped
    interval: 30s
    # Timeout after which the scrape is ended
    scrapeTimeout: 10s
    # Additional labels for ServiceMonitor
    labels: {}

# Memcached Exporter sidecar for Prometheus metrics
# See: https://github.com/prometheus/memcached_exporter
metrics:
  enabled: false
  image:
    repository: prom/memcached-exporter
    tag: v0.14.4
    pullPolicy: IfNotPresent
  resources:
    limits:
      cpu: 100m
      memory: 128Mi
    requests:
      cpu: 50m
      memory: 64Mi
  port: 9150

# 15. Scheduling

# Node selector for pod assignment
nodeSelector: {}

# Tolerations for pod assignment
tolerations: []

# Affinity for pod assignment
affinity: {}
# Example anti-affinity for HA:
# affinity:
#   podAntiAffinity:
#     preferredDuringSchedulingIgnoredDuringExecution:
#       - weight: 100
#         podAffinityTerm:
#           labelSelector:
#             matchExpressions:
#               - key: app.kubernetes.io/name
#                 operator: In
#                 values:
#                   - memcached
#           topologyKey: kubernetes.io/hostname

# 16. Extensibility

# Additional environment variables
extraEnv: []
#  - name: EXAMPLE_ENV
#    value: "example-value"

# Additional environment variables from ConfigMap or Secret
extraEnvFrom: []

# Additional volumes
extraVolumes: []
#  - name: cache-socket
#    emptyDir: {}

# Additional volume mounts
extraVolumeMounts: []
#  - name: cache-socket
#    mountPath: /var/run/memcached

# Init containers
initContainers: []

# Lifecycle hooks
lifecycle: {}
# Example:
# lifecycle:
#   preStop:
#     exec:
#       command: ["/bin/sh", "-c", "sleep 5"]
