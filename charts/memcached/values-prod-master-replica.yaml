# Production scenario for memcached - Multiple Independent Instances
# High availability with multiple replicas
# Full monitoring, autoscaling, and network policies
#
# ⚠️ IMPORTANT: Memcached Architecture Clarification
#
# Despite the filename "prod-master-replica", Memcached does NOT have a master-replica
# architecture like Redis or PostgreSQL. Each Memcached instance is INDEPENDENT and
# does NOT replicate data to other instances.
#
# This deployment creates multiple INDEPENDENT Memcached instances that:
#   - Do NOT share data with each other
#   - Do NOT replicate cache entries
#   - Are accessed via a shared Service (round-robin load balancing by default)
#   - Require CLIENT-SIDE consistent hashing for proper data distribution
#
# For proper production use:
#   1. Use a client library that supports consistent hashing (e.g., libmemcached, pylibmc)
#   2. Configure clients to connect to individual pod IPs or use StatefulSet headless service
#   3. Client maintains consistent hash ring to distribute keys across instances
#
# Why multiple instances?
#   - Increased total cache capacity (3 instances × 512MB = 1.5GB total)
#   - Better availability (if one instance fails, others continue serving)
#   - Horizontal scaling of cache operations
#
# Alternative: Use single large instance with more memory if consistent hashing is not feasible

# 1. Application-specific Configuration

memcached:
  # Production memory allocation (512MB)
  maxMemory: 512

  # High connection limit for production
  maxConnections: 2048

  chunkSizeGrowthFactor: 1.25
  minItemSize: 48
  enableCas: true
  verbosity: 0
  # Production optimizations
  extraArgs:
    - "-o"
    - "modern"  # Modern memory allocator

# 4. Kubernetes Resources

replicaCount: 3

image:
  repository: memcached
  pullPolicy: IfNotPresent
  tag: "1.6.39-alpine3.22"

strategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 1
    maxSurge: 1

# 5. Service Account

serviceAccount:
  create: true
  automount: true

# 6. Pod Configuration

podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "9150"

podSecurityContext:
  fsGroup: 11211
  runAsUser: 11211
  runAsGroup: 11211
  runAsNonRoot: true

securityContext:
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 11211
  runAsGroup: 11211
  allowPrivilegeEscalation: false

# 7. Service Configuration

service:
  type: ClusterIP
  port: 11211

# 9. Resources - Production grade

resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 250m
    memory: 512Mi

# 10. Health Probes

livenessProbe:
  enabled: true
  tcpSocket:
    port: 11211
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1

readinessProbe:
  enabled: true
  tcpSocket:
    port: 11211
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 3
  failureThreshold: 3
  successThreshold: 1

startupProbe:
  enabled: true
  tcpSocket:
    port: memcached
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 10
  successThreshold: 1

# 11. Autoscaling - Enabled

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

# 12. Pod Disruption Budget - Enabled

podDisruptionBudget:
  enabled: true
  minAvailable: 2
  # Ensures at least 2 pods available during voluntary disruptions

# 13. Network Policy - Enabled

networkPolicy:
  enabled: true
  ingress:
    # Allow from application pods (customize labels as needed)
    - from:
        - podSelector:
            matchLabels:
              app.kubernetes.io/name: myapp
      ports:
        - protocol: TCP
          port: 11211
    # Allow from monitoring namespace
    - from:
        - namespaceSelector:
            matchLabels:
              name: monitoring
      ports:
        - protocol: TCP
          port: 9150
  egress:
    # Allow DNS
    - to:
        - namespaceSelector: {}
      ports:
        - protocol: UDP
          port: 53

# 14. Monitoring - Metrics enabled, ServiceMonitor disabled by default

monitoring:
  enabled: true
  serviceMonitor:
    # Enable this if Prometheus Operator is installed
    enabled: false
    interval: 30s
    scrapeTimeout: 10s

metrics:
  enabled: true
  image:
    repository: prom/memcached-exporter
    tag: v0.14.4
    pullPolicy: IfNotPresent
  resources:
    limits:
      cpu: 100m
      memory: 128Mi
    requests:
      cpu: 50m
      memory: 64Mi
  port: 9150

# 15. Scheduling - Anti-affinity for HA

nodeSelector: {}
tolerations: []

affinity:
  podAntiAffinity:
    # Prefer different nodes
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - memcached
          topologyKey: kubernetes.io/hostname
